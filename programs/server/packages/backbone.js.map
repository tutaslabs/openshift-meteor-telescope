{"version":3,"file":"/packages/backbone.js","sources":["backbone/backbone.js"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA,wB;;AAEA,wD;AACA,gE;AACA,yC;AACA,4B;;AAEA,+D;;AAEA,Y;;AAEA,kB;AACA,kB;;AAEA,6E;AACA,oB;AACA,kB;;AAEA,0E;AACA,gD;AACA,uC;;AAEA,8C;AACA,oC;AACA,sC;;AAEA,0E;AACA,qE;AACA,e;AACA,uC;AACA,uB;AACA,U;AACA,kC;AACA,G;;AAEA,sE;AACA,6B;;AAEA,8E;AACA,+D;AACA,oB;AACA,2E;AACA,c;;AAEA,4E;AACA,kD;;AAEA,0E;AACA,gF;AACA,yE;AACA,2E;AACA,2B;AACA,0C;AACA,Y;AACA,I;;AAEA,6E;AACA,wE;AACA,oC;AACA,qC;AACA,gB;AACA,I;;AAEA,8E;AACA,8E;AACA,2C;AACA,+B;;AAEA,gF;AACA,4D;AACA,6E;AACA,8B;AACA,+B;;AAEA,oB;AACA,sB;;AAEA,mD;AACA,4B;;AAEA,8E;AACA,kF;AACA,0E;AACA,I;AACA,yB;AACA,2C;AACA,+D;AACA,kC;AACA,I;AACA,kC;;AAEA,yE;AACA,4E;AACA,6C;;AAEA,yC;AACA,iC;AACA,2C;AACA,wD;;AAEA,qE;AACA,4E;AACA,0B;AACA,sC;AACA,4B;AACA,qC;AACA,8B;AACA,+B;AACA,iC;AACA,mE;AACA,O;;AAEA,kB;AACA,M;;AAEA,gF;AACA,+E;AACA,8E;AACA,8C;AACA,4C;;AAEA,6C;AACA,6C;AACA,6C;AACA,+B;AACA,oB;AACA,O;;AAEA,8E;AACA,iD;AACA,oE;AACA,sC;AACA,4B;AACA,4B;AACA,sD;AACA,+D;AACA,yB;AACA,6C;AACA,6B;AACA,6B;AACA,8E;AACA,oC;AACA,W;AACA,S;AACA,O;;AAEA,kB;AACA,M;;AAEA,4E;AACA,2E;AACA,6E;AACA,iE;AACA,+B;AACA,oD;AACA,kD;AACA,sB;AACA,2C;AACA,sC;;AAEA,yE;AACA,2E;AACA,sC;AACA,kC;AACA,2B;AACA,+C;AACA,4D;AACA,W;AACA,S;AACA,yB;AACA,2B;AACA,sC;AACA,+C;AACA,4D;AACA,W;AACA,S;AACA,O;;AAEA,kB;AACA,K;;AAEA,I;;AAEA,yC;AACA,4B;AACA,6B;;AAEA,mB;AACA,mB;;AAEA,qE;AACA,qD;AACA,8D;AACA,iB;AACA,oC;AACA,sE;AACA,gD;AACA,sD;AACA,K;AACA,4E;AACA,yB;AACA,iC;AACA,+B;AACA,sB;AACA,sB;AACA,uB;AACA,yC;AACA,6B;AACA,sB;AACA,sB;AACA,uB;AACA,wD;AACA,2C;AACA,I;;AAEA,2D;AACA,qC;;AAEA,oE;AACA,kB;;AAEA,0E;AACA,6E;AACA,kB;;AAEA,6E;AACA,a;AACA,mB;;AAEA,0E;AACA,qD;AACA,sB;;AAEA,4E;AACA,4B;AACA,6B;;AAEA,wD;AACA,+B;AACA,sC;AACA,M;;AAEA,qC;AACA,yB;AACA,mC;AACA,M;;AAEA,kD;AACA,4B;AACA,e;AACA,4D;AACA,+B;AACA,mF;AACA,M;;AAEA,wE;AACA,oB;AACA,yB;AACA,oC;AACA,M;;AAEA,6E;AACA,gC;AACA,wC;AACA,2B;;AAEA,wE;AACA,2C;AACA,oB;AACA,wB;AACA,c;AACA,mB;AACA,2B;AACA,O;;AAEA,wC;AACA,gC;AACA,8B;AACA,2D;AACA,kE;;AAEA,wB;AACA,wD;;AAEA,mC;AACA,uE;;AAEA,yC;AACA,gC;AACA,4C;AACA,gD;;AAEA,oC;AACA,2B;AACA,0B;;AAEA,kE;AACA,gF;AACA,+B;AACA,iE;AACA,S;;AAEA,8C;AACA,2D;;AAEA,4E;AACA,kD;AACA,qF;AACA,mC;AACA,0D;AACA,gB;AACA,oC;AACA,qC;AACA,S;AACA,O;;AAEA,oC;AACA,gD;AACA,kB;AACA,M;;AAEA,8E;AACA,uE;AACA,oC;AACA,+C;AACA,2C;AACA,M;;AAEA,6E;AACA,qB;AACA,8B;AACA,+C;AACA,yD;AACA,M;;AAEA,6E;AACA,yE;AACA,qC;AACA,8B;AACA,gD;AACA,uB;AACA,oC;AACA,qD;AACA,sE;AACA,0C;AACA,Q;AACA,wE;AACA,4E;AACA,M;;AAEA,wE;AACA,yE;AACA,iC;AACA,yC;AACA,yB;;AAEA,wE;AACA,2C;AACA,oB;AACA,wB;AACA,c;AACA,mB;AACA,2B;AACA,O;AACA,gD;;AAEA,uE;AACA,yB;AACA,0D;AACA,2C;AACA,O;;AAEA,wE;AACA,gE;AACA,8E;AACA,qB;AACA,O;;AAEA,wE;AACA,4C;AACA,uB;AACA,oC;AACA,qD;AACA,iD;AACA,2B;AACA,8B;AACA,2D;AACA,S;AACA,2D;AACA,sB;AACA,+B;AACA,gB;AACA,sD;AACA,S;AACA,Q;;AAEA,yD;AACA,wE;AACA,sD;AACA,+E;AACA,yD;AACA,iB;AACA,M;;AAEA,oE;AACA,2E;AACA,iF;AACA,gC;AACA,gD;AACA,uB;AACA,oC;;AAEA,uC;AACA,mE;AACA,Q;;AAEA,yB;AACA,yB;AACA,qB;AACA,O;;AAEA,wC;AACA,2C;AACA,sB;AACA,+B;AACA,gB;AACA,sD;AACA,S;AACA,Q;;AAEA,wE;AACA,iF;AACA,0C;AACA,iB;AACA,M;;AAEA,4E;AACA,6E;AACA,2B;AACA,qB;AACA,6F;AACA,oC;AACA,mG;AACA,M;;AAEA,+E;AACA,gF;AACA,gC;AACA,kB;AACA,M;;AAEA,gE;AACA,uB;AACA,mD;AACA,M;;AAEA,gF;AACA,uB;AACA,6B;AACA,M;;AAEA,8E;AACA,+D;AACA,yE;AACA,+B;AACA,gC;AACA,oC;AACA,4B;;AAEA,+C;AACA,gE;;AAEA,sC;AACA,gE;AACA,wB;AACA,iC;AACA,sE;AACA,O;AACA,gC;;AAEA,2E;AACA,yC;AACA,2B;AACA,8C;AACA,mD;AACA,wC;AACA,kE;AACA,oC;AACA,S;AACA,4D;AACA,O;;AAEA,6B;AACA,kB;AACA,M;;AAEA,0E;AACA,iF;AACA,gC;AACA,6D;AACA,uC;AACA,M;;AAEA,2E;AACA,4E;AACA,2E;AACA,0E;AACA,wE;AACA,gD;AACA,uC;AACA,0E;AACA,+D;AACA,8B;AACA,+D;AACA,gD;AACA,O;AACA,qB;AACA,M;;AAEA,4E;AACA,kC;AACA,8B;AACA,sE;AACA,4C;AACA,M;;AAEA,yE;AACA,wB;AACA,oC;AACA,+C;AACA,M;;AAEA,8E;AACA,kE;AACA,yB;AACA,6C;AACA,M;;AAEA,wE;AACA,0E;AACA,4E;AACA,yC;AACA,wD;AACA,mD;AACA,gD;AACA,8B;AACA,qC;AACA,4C;AACA,c;AACA,oD;AACA,O;AACA,mB;AACA,K;;AAEA,K;;AAEA,wB;AACA,wB;;AAEA,yE;AACA,+E;AACA,4D;AACA,oE;AACA,8B;AACA,kD;AACA,iE;AACA,kB;AACA,2C;AACA,yE;AACA,I;;AAEA,iD;AACA,0C;;AAEA,uE;AACA,+C;AACA,iB;;AAEA,4E;AACA,4B;AACA,6B;;AAEA,iE;AACA,0B;AACA,+B;AACA,wE;AACA,M;;AAEA,0E;AACA,kD;AACA,oC;AACA,2E;AACA,gC;AACA,6D;;AAEA,4E;AACA,6D;AACA,4D;AACA,4E;AACA,wE;AACA,S;AACA,wB;AACA,sB;AACA,6F;AACA,uB;AACA,mB;AACA,S;AACA,oC;AACA,O;;AAEA,2B;AACA,sB;AACA,mB;AACA,kC;AACA,O;;AAEA,uE;AACA,2B;AACA,4D;AACA,gE;AACA,uC;AACA,2D;AACA,O;;AAEA,gF;AACA,sC;AACA,4B;AACA,mE;AACA,2D;AACA,qD;AACA,sC;AACA,iE;AACA,0D;AACA,0B;AACA,mD;AACA,O;AACA,kB;AACA,M;;AAEA,6E;AACA,yD;AACA,uC;AACA,6B;AACA,gC;AACA,6D;AACA,kD;AACA,gE;AACA,6B;AACA,oC;AACA,sC;AACA,oC;AACA,qC;AACA,sB;AACA,8B;AACA,gC;AACA,wD;AACA,S;AACA,qC;AACA,O;AACA,kB;AACA,M;;AAEA,gD;AACA,oC;AACA,iD;AACA,+B;AACA,mB;AACA,M;;AAEA,qD;AACA,4B;AACA,2C;AACA,kC;AACA,mB;AACA,M;;AAEA,sD;AACA,uC;AACA,iD;AACA,kD;AACA,mB;AACA,M;;AAEA,2D;AACA,8B;AACA,6B;AACA,kC;AACA,mB;AACA,M;;AAEA,sC;AACA,uB;AACA,oC;AACA,oD;AACA,M;;AAEA,6C;AACA,6B;AACA,gD;AACA,M;;AAEA,wC;AACA,yB;AACA,gC;AACA,M;;AAEA,mF;AACA,4B;AACA,sC;AACA,0C;AACA,gC;AACA,0D;AACA,S;AACA,oB;AACA,S;AACA,M;;AAEA,gF;AACA,6E;AACA,gB;AACA,6B;AACA,gC;AACA,sF;AACA,0D;AACA,wC;AACA,mD;AACA,c;AACA,0C;AACA,O;AACA,gE;AACA,kB;AACA,M;;AAEA,4D;AACA,2B;AACA,4E;AACA,M;;AAEA,4E;AACA,6E;AACA,iE;AACA,sC;AACA,+B;AACA,gC;AACA,2D;AACA,8C;AACA,O;AACA,oB;AACA,0D;AACA,gE;AACA,kB;AACA,M;;AAEA,yE;AACA,yE;AACA,qD;AACA,8B;AACA,gD;AACA,4D;AACA,4B;AACA,oC;AACA,qD;AACA,wF;AACA,+C;AACA,Q;AACA,6E;AACA,4E;AACA,M;;AAEA,gF;AACA,8E;AACA,oC;AACA,sC;AACA,sB;AACA,gD;AACA,iD;AACA,+B;AACA,kD;AACA,oC;AACA,wD;AACA,uD;AACA,sB;AACA,mC;AACA,gB;AACA,0D;AACA,S;AACA,Q;AACA,gC;AACA,mB;AACA,M;;AAEA,6E;AACA,yE;AACA,gC;AACA,kB;AACA,M;;AAEA,wE;AACA,yE;AACA,mB;AACA,wB;AACA,oC;AACA,M;;AAEA,qE;AACA,+B;AACA,sB;AACA,uB;AACA,uB;AACA,uB;AACA,M;;AAEA,4E;AACA,6C;AACA,gC;AACA,sC;AACA,0B;AACA,kC;AACA,+C;AACA,uE;AACA,qC;AACA,gC;AACA,O;AACA,mB;AACA,M;;AAEA,gE;AACA,uC;AACA,qC;AACA,gC;AACA,O;AACA,iD;AACA,M;;AAEA,2E;AACA,0E;AACA,4E;AACA,wC;AACA,gE;AACA,8E;AACA,+B;AACA,oC;AACA,O;AACA,6D;AACA,6D;AACA,qC;AACA,O;AACA,0C;AACA,K;;AAEA,K;;AAEA,oE;AACA,2E;AACA,0E;AACA,2E;AACA,gF;AACA,oD;;AAEA,qE;AACA,oC;AACA,+C;AACA,4E;AACA,M;AACA,K;;AAEA,oB;AACA,wB;;AAEA,sE;AACA,+E;AACA,oD;AACA,8B;AACA,qD;AACA,uB;AACA,2C;AACA,I;;AAEA,2E;AACA,4B;AACA,8B;AACA,+B;AACA,gD;;AAEA,uE;AACA,sC;;AAEA,4E;AACA,4B;AACA,6B;;AAEA,qE;AACA,M;AACA,6E;AACA,gB;AACA,c;AACA,M;AACA,4C;AACA,2D;AACA,iE;AACA,2C;AACA,+D;AACA,4D;AACA,+C;AACA,iE;AACA,4D;AACA,gB;AACA,kB;AACA,M;;AAEA,8E;AACA,2C;AACA,mD;AACA,M;;AAEA,4E;AACA,0E;AACA,4D;AACA,6B;AACA,+B;AACA,sB;AACA,sC;AACA,oD;AACA,O;AACA,sD;AACA,mE;AACA,O;AACA,M;;AAEA,8E;AACA,yC;AACA,qC;AACA,iD;AACA,mD;AACA,iD;AACA,2C;AACA,M;;AAEA,6E;AACA,4B;AACA,mD;AACA,2C;AACA,K;;AAEA,K;;AAEA,qB;AACA,qB;;AAEA,6E;AACA,oE;AACA,+C;AACA,uB;AACA,gC;AACA,I;;AAEA,2D;AACA,+B;;AAEA,qC;AACA,iC;;AAEA,mD;AACA,0B;;AAEA,wE;AACA,uC;;AAEA,sE;AACA,6B;AACA,iB;;AAEA,6E;AACA,6D;AACA,uC;AACA,2E;AACA,2C;AACA,mC;AACA,M;;AAEA,0E;AACA,iC;AACA,qD;AACA,6B;AACA,mD;AACA,8C;AACA,8C;AACA,yC;AACA,gB;AACA,oC;AACA,S;AACA,O;AACA,qG;AACA,iD;AACA,M;;AAEA,kF;AACA,gD;AACA,8B;AACA,wF;AACA,iB;AACA,wC;AACA,sF;AACA,kB;AACA,6B;;AAEA,oE;AACA,kD;AACA,+E;AACA,gE;AACA,uD;AACA,uG;AACA,iD;AACA,oD;AACA,iH;;AAEA,kB;AACA,gH;AACA,gC;AACA,O;;AAEA,0E;AACA,2E;AACA,+B;AACA,kD;AACA,iF;AACA,oD;AACA,yC;AACA,2E;AACA,O;;AAEA,0E;AACA,2C;AACA,+B;AACA,gC;AACA,sD;;AAEA,8E;AACA,oE;AACA,4F;AACA,qD;AACA,yE;AACA,oE;AACA,oB;;AAEA,6E;AACA,oE;AACA,oF;AACA,kE;AACA,4H;AACA,O;;AAEA,iC;AACA,8B;AACA,O;AACA,M;;AAEA,+E;AACA,oD;AACA,sB;AACA,sF;AACA,4C;AACA,8B;AACA,M;;AAEA,6E;AACA,oC;AACA,sC;AACA,gE;AACA,M;;AAEA,sE;AACA,6D;AACA,2B;AACA,uC;AACA,yG;AACA,iD;AACA,8C;AACA,qD;AACA,M;;AAEA,2E;AACA,wE;AACA,uB;AACA,yC;AACA,wE;AACA,4D;AACA,2C;AACA,qC;AACA,sB;AACA,S;AACA,S;AACA,qB;AACA,M;;AAEA,6E;AACA,gF;AACA,+B;AACA,M;AACA,6E;AACA,8E;AACA,iF;AACA,2C;AACA,yC;AACA,qE;AACA,6D;AACA,wC;;AAEA,gF;AACA,+B;AACA,kF;AACA,6B;AACA,iG;;AAEA,0E;AACA,mC;AACA,yC;AACA,6B;AACA,iE;AACA,mF;AACA,8G;AACA,sD;AACA,mE;AACA,wE;AACA,S;;AAEA,8E;AACA,+D;AACA,c;AACA,6D;AACA,O;AACA,kD;AACA,M;;AAEA,8E;AACA,wC;AACA,wD;AACA,oB;AACA,iG;AACA,c;AACA,iC;AACA,O;AACA,K;AACA,K;;AAEA,kB;AACA,kB;;AAEA,6E;AACA,8C;AACA,gD;AACA,kC;AACA,mC;AACA,0B;AACA,2C;AACA,0B;AACA,I;;AAEA,+C;AACA,+C;;AAEA,qD;AACA,8F;;AAEA,qE;AACA,oC;;AAEA,4D;AACA,mB;;AAEA,4E;AACA,8E;AACA,2B;AACA,qC;AACA,M;;AAEA,4E;AACA,4B;AACA,6B;;AAEA,+E;AACA,0E;AACA,4D;AACA,wB;AACA,kB;AACA,M;;AAEA,6E;AACA,6D;AACA,wB;AACA,wB;AACA,kB;AACA,M;;AAEA,2E;AACA,mE;AACA,M;AACA,kF;AACA,M;AACA,kD;AACA,+C;AACA,6C;AACA,uC;AACA,gB;AACA,M;;AAEA,sE;AACA,qB;AACA,6C;AACA,4C;AACA,+D;AACA,4B;AACA,oD;AACA,kB;AACA,M;;AAEA,sD;AACA,M;AACA,uC;AACA,M;AACA,Y;AACA,yC;AACA,wC;AACA,qD;AACA,Y;AACA,M;AACA,4E;AACA,4C;AACA,0D;AACA,yE;AACA,gE;AACA,sC;AACA,mE;AACA,8B;AACA,+B;AACA,iC;AACA,8D;AACA,oF;AACA,qD;AACA,sD;AACA,sC;AACA,kD;AACA,8B;AACA,2C;AACA,gB;AACA,yD;AACA,S;AACA,O;AACA,M;;AAEA,+E;AACA,+E;AACA,uD;AACA,kC;AACA,oD;AACA,M;;AAEA,0E;AACA,0E;AACA,qC;AACA,mC;AACA,sE;AACA,2D;AACA,kC;AACA,sD;AACA,O;AACA,6B;AACA,M;;AAEA,6D;AACA,sE;AACA,oE;AACA,sE;AACA,gC;AACA,qB;AACA,uD;AACA,wC;AACA,4D;AACA,+D;AACA,c;AACA,wC;AACA,O;AACA,K;;AAEA,K;;AAEA,oE;AACA,kD;AACA,uD;AACA,+B;AACA,iB;AACA,I;;AAEA,4D;AACA,0E;;AAEA,kB;AACA,kB;;AAEA,0E;AACA,mB;AACA,qB;AACA,oB;AACA,uB;AACA,mB;AACA,I;;AAEA,2E;AACA,0E;AACA,gE;AACA,mE;AACA,I;AACA,0E;AACA,iD;AACA,qD;AACA,I;AACA,gF;AACA,2E;AACA,iF;AACA,2E;AACA,8E;AACA,qD;AACA,oD;AACA,iC;;AAEA,yC;AACA,8B;;AAEA,oC;AACA,gD;;AAEA,iC;AACA,uB;AACA,wD;AACA,K;;AAEA,wD;AACA,+E;AACA,8C;AACA,mD;AACA,K;;AAEA,iF;AACA,+B;AACA,+D;AACA,4D;AACA,K;;AAEA,kF;AACA,8C;AACA,+B;AACA,gD;AACA,6D;AACA,6B;AACA,2C;AACA,+D;AACA,U;AACA,O;AACA,K;;AAEA,+C;AACA,yD;AACA,iC;AACA,K;;AAEA,wE;AACA,6C;AACA,I;;AAEA,iE;AACA,kE;AACA,kC;AACA,oD;AACA,oB;AACA,8C;AACA,c;AACA,qE;AACA,O;AACA,M;AACA,I;;AAEA,Y;AACA,Y;;AAEA,0E;AACA,0B;;AAEA,6E;AACA,4E;AACA,qC;AACA,4D;AACA,c;;AAEA,6E;AACA,6E;AACA,qD;AACA,iE;AACA,qC;AACA,Y;AACA,2D;AACA,K;;AAEA,qD;AACA,4B;;AAEA,wE;AACA,uC;AACA,sC;AACA,iC;;AAEA,sE;AACA,mB;AACA,0D;;AAEA,sE;AACA,kD;;AAEA,qD;AACA,wC;;AAEA,iF;AACA,uC;;AAEA,iB;AACA,I;;AAEA,wE;AACA,sB;AACA,yC;AACA,+C;AACA,sE;AACA,I;;AAEA,+D;AACA,6B;AACA,sE;AACA,I;;AAEA,c","sourcesContent":["//     Backbone.js 0.9.2\n\n//     (c) 2010-2012 Jeremy Ashkenas, DocumentCloud Inc.\n//     Backbone may be freely distributed under the MIT license.\n//     For all details and documentation:\n//     http://backbonejs.org\n\n// Meteor changes occur inside <METEOR> </METEOR> -- dgreenspan\n\n(function(){\n\n  // Initial Setup\n  // -------------\n\n  // Save a reference to the global object (`window` in the browser, `global`\n  // on the server).\n  var root = this;\n\n  // Save the previous value of the `Backbone` variable, so that it can be\n  // restored later on, if `noConflict` is used.\n  var previousBackbone = root.Backbone;\n\n  // Create a local reference to slice/splice.\n  var slice = Array.prototype.slice;\n  var splice = Array.prototype.splice;\n\n  // The top-level namespace. All public Backbone classes and modules will\n  // be attached to this. Exported for both CommonJS and the browser.\n  var Backbone;\n  if (typeof exports !== 'undefined') {\n    Backbone = exports;\n  } else {\n    Backbone = root.Backbone = {};\n  }\n\n  // Current version of the library. Keep in sync with `package.json`.\n  Backbone.VERSION = '0.9.2';\n\n  // Require Underscore, if we're on the server, and it's not already present.\n  // <METEOR> Commented these lines out; we have _ via api.use.\n  // var _ = root._;\n  // if (!_ && (typeof require !== 'undefined')) _ = require('underscore');\n  // </METEOR>\n\n  // For Backbone's purposes, jQuery, Zepto, or Ender owns the `$` variable.\n  var $ = root.jQuery || root.Zepto || root.ender;\n\n  // Set the JavaScript library that will be used for DOM manipulation and\n  // Ajax calls (a.k.a. the `$` variable). By default Backbone will use: jQuery,\n  // Zepto, or Ender; but the `setDomLibrary()` method lets you inject an\n  // alternate JavaScript library (or a mock library for testing your views\n  // outside of a browser).\n  Backbone.setDomLibrary = function(lib) {\n    $ = lib;\n  };\n\n  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable\n  // to its previous owner. Returns a reference to this Backbone object.\n  Backbone.noConflict = function() {\n    root.Backbone = previousBackbone;\n    return this;\n  };\n\n  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option\n  // will fake `\"PUT\"` and `\"DELETE\"` requests via the `_method` parameter and\n  // set a `X-Http-Method-Override` header.\n  Backbone.emulateHTTP = false;\n\n  // Turn on `emulateJSON` to support legacy servers that can't deal with direct\n  // `application/json` requests ... will encode the body as\n  // `application/x-www-form-urlencoded` instead and will send the model in a\n  // form param named `model`.\n  Backbone.emulateJSON = false;\n\n  // Backbone.Events\n  // -----------------\n\n  // Regular expression used to split event strings\n  var eventSplitter = /\\s+/;\n\n  // A module that can be mixed in to *any object* in order to provide it with\n  // custom events. You may bind with `on` or remove with `off` callback functions\n  // to an event; trigger`-ing an event fires all callbacks in succession.\n  //\n  //     var object = {};\n  //     _.extend(object, Backbone.Events);\n  //     object.on('expand', function(){ alert('expanded'); });\n  //     object.trigger('expand');\n  //\n  var Events = Backbone.Events = {\n\n    // Bind one or more space separated events, `events`, to a `callback`\n    // function. Passing `\"all\"` will bind the callback to all events fired.\n    on: function(events, callback, context) {\n\n      var calls, event, node, tail, list;\n      if (!callback) return this;\n      events = events.split(eventSplitter);\n      calls = this._callbacks || (this._callbacks = {});\n\n      // Create an immutable callback list, allowing traversal during\n      // modification.  The tail is an empty object that will always be used\n      // as the next node.\n      while (event = events.shift()) {\n        list = calls[event];\n        node = list ? list.tail : {};\n        node.next = tail = {};\n        node.context = context;\n        node.callback = callback;\n        calls[event] = {tail: tail, next: list ? list.next : node};\n      }\n\n      return this;\n    },\n\n    // Remove one or many callbacks. If `context` is null, removes all callbacks\n    // with that function. If `callback` is null, removes all callbacks for the\n    // event. If `events` is null, removes all bound callbacks for all events.\n    off: function(events, callback, context) {\n      var event, calls, node, tail, cb, ctx;\n\n      // No events, or removing *all* events.\n      if (!(calls = this._callbacks)) return;\n      if (!(events || callback || context)) {\n        delete this._callbacks;\n        return this;\n      }\n\n      // Loop through the listed events and contexts, splicing them out of the\n      // linked list of callbacks if appropriate.\n      events = events ? events.split(eventSplitter) : _.keys(calls);\n      while (event = events.shift()) {\n        node = calls[event];\n        delete calls[event];\n        if (!node || !(callback || context)) continue;\n        // Create a new list, omitting the indicated callbacks.\n        tail = node.tail;\n        while ((node = node.next) !== tail) {\n          cb = node.callback;\n          ctx = node.context;\n          if ((callback && cb !== callback) || (context && ctx !== context)) {\n            this.on(event, cb, ctx);\n          }\n        }\n      }\n\n      return this;\n    },\n\n    // Trigger one or many events, firing all bound callbacks. Callbacks are\n    // passed the same arguments as `trigger` is, apart from the event name\n    // (unless you're listening on `\"all\"`, which will cause your callback to\n    // receive the true name of the event as the first argument).\n    trigger: function(events) {\n      var event, node, calls, tail, args, all, rest;\n      if (!(calls = this._callbacks)) return this;\n      all = calls.all;\n      events = events.split(eventSplitter);\n      rest = slice.call(arguments, 1);\n\n      // For each event, walk through the linked list of callbacks twice,\n      // first to trigger the event, then to trigger any `\"all\"` callbacks.\n      while (event = events.shift()) {\n        if (node = calls[event]) {\n          tail = node.tail;\n          while ((node = node.next) !== tail) {\n            node.callback.apply(node.context || this, rest);\n          }\n        }\n        if (node = all) {\n          tail = node.tail;\n          args = [event].concat(rest);\n          while ((node = node.next) !== tail) {\n            node.callback.apply(node.context || this, args);\n          }\n        }\n      }\n\n      return this;\n    }\n\n  };\n\n  // Aliases for backwards compatibility.\n  Events.bind   = Events.on;\n  Events.unbind = Events.off;\n\n  // Backbone.Model\n  // --------------\n\n  // Create a new model, with defined attributes. A client id (`cid`)\n  // is automatically generated and assigned for you.\n  var Model = Backbone.Model = function(attributes, options) {\n    var defaults;\n    attributes || (attributes = {});\n    if (options && options.parse) attributes = this.parse(attributes);\n    if (defaults = getValue(this, 'defaults')) {\n      attributes = _.extend({}, defaults, attributes);\n    }\n    if (options && options.collection) this.collection = options.collection;\n    this.attributes = {};\n    this._escapedAttributes = {};\n    this.cid = _.uniqueId('c');\n    this.changed = {};\n    this._silent = {};\n    this._pending = {};\n    this.set(attributes, {silent: true});\n    // Reset change tracking.\n    this.changed = {};\n    this._silent = {};\n    this._pending = {};\n    this._previousAttributes = _.clone(this.attributes);\n    this.initialize.apply(this, arguments);\n  };\n\n  // Attach all inheritable methods to the Model prototype.\n  _.extend(Model.prototype, Events, {\n\n    // A hash of attributes whose current and previous value differ.\n    changed: null,\n\n    // A hash of attributes that have silently changed since the last time\n    // `change` was called.  Will become pending attributes on the next call.\n    _silent: null,\n\n    // A hash of attributes that have changed since the last `'change'` event\n    // began.\n    _pending: null,\n\n    // The default name for the JSON `id` attribute is `\"id\"`. MongoDB and\n    // CouchDB users may want to set this to `\"_id\"`.\n    idAttribute: 'id',\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){},\n\n    // Return a copy of the model's `attributes` object.\n    toJSON: function(options) {\n      return _.clone(this.attributes);\n    },\n\n    // Get the value of an attribute.\n    get: function(attr) {\n      return this.attributes[attr];\n    },\n\n    // Get the HTML-escaped value of an attribute.\n    escape: function(attr) {\n      var html;\n      if (html = this._escapedAttributes[attr]) return html;\n      var val = this.get(attr);\n      return this._escapedAttributes[attr] = _.escape(val == null ? '' : '' + val);\n    },\n\n    // Returns `true` if the attribute contains a value that is not null\n    // or undefined.\n    has: function(attr) {\n      return this.get(attr) != null;\n    },\n\n    // Set a hash of model attributes on the object, firing `\"change\"` unless\n    // you choose to silence it.\n    set: function(key, value, options) {\n      var attrs, attr, val;\n\n      // Handle both `\"key\", value` and `{key: value}` -style arguments.\n      if (_.isObject(key) || key == null) {\n        attrs = key;\n        options = value;\n      } else {\n        attrs = {};\n        attrs[key] = value;\n      }\n\n      // Extract attributes and options.\n      options || (options = {});\n      if (!attrs) return this;\n      if (attrs instanceof Model) attrs = attrs.attributes;\n      if (options.unset) for (attr in attrs) attrs[attr] = void 0;\n\n      // Run validation.\n      if (!this._validate(attrs, options)) return false;\n\n      // Check for changes of `id`.\n      if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];\n\n      var changes = options.changes = {};\n      var now = this.attributes;\n      var escaped = this._escapedAttributes;\n      var prev = this._previousAttributes || {};\n\n      // For each `set` attribute...\n      for (attr in attrs) {\n        val = attrs[attr];\n\n        // If the new and current value differ, record the change.\n        if (!_.isEqual(now[attr], val) || (options.unset && _.has(now, attr))) {\n          delete escaped[attr];\n          (options.silent ? this._silent : changes)[attr] = true;\n        }\n\n        // Update or delete the current value.\n        options.unset ? delete now[attr] : now[attr] = val;\n\n        // If the new and previous value differ, record the change.  If not,\n        // then remove changes for this attribute.\n        if (!_.isEqual(prev[attr], val) || (_.has(now, attr) != _.has(prev, attr))) {\n          this.changed[attr] = val;\n          if (!options.silent) this._pending[attr] = true;\n        } else {\n          delete this.changed[attr];\n          delete this._pending[attr];\n        }\n      }\n\n      // Fire the `\"change\"` events.\n      if (!options.silent) this.change(options);\n      return this;\n    },\n\n    // Remove an attribute from the model, firing `\"change\"` unless you choose\n    // to silence it. `unset` is a noop if the attribute doesn't exist.\n    unset: function(attr, options) {\n      (options || (options = {})).unset = true;\n      return this.set(attr, null, options);\n    },\n\n    // Clear all attributes on the model, firing `\"change\"` unless you choose\n    // to silence it.\n    clear: function(options) {\n      (options || (options = {})).unset = true;\n      return this.set(_.clone(this.attributes), options);\n    },\n\n    // Fetch the model from the server. If the server's representation of the\n    // model differs from its current attributes, they will be overriden,\n    // triggering a `\"change\"` event.\n    fetch: function(options) {\n      options = options ? _.clone(options) : {};\n      var model = this;\n      var success = options.success;\n      options.success = function(resp, status, xhr) {\n        if (!model.set(model.parse(resp, xhr), options)) return false;\n        if (success) success(model, resp);\n      };\n      options.error = Backbone.wrapError(options.error, model, options);\n      return (this.sync || Backbone.sync).call(this, 'read', this, options);\n    },\n\n    // Set a hash of model attributes, and sync the model to the server.\n    // If the server returns an attributes hash that differs, the model's\n    // state will be `set` again.\n    save: function(key, value, options) {\n      var attrs, current;\n\n      // Handle both `(\"key\", value)` and `({key: value})` -style calls.\n      if (_.isObject(key) || key == null) {\n        attrs = key;\n        options = value;\n      } else {\n        attrs = {};\n        attrs[key] = value;\n      }\n      options = options ? _.clone(options) : {};\n\n      // If we're \"wait\"-ing to set changed attributes, validate early.\n      if (options.wait) {\n        if (!this._validate(attrs, options)) return false;\n        current = _.clone(this.attributes);\n      }\n\n      // Regular saves `set` attributes before persisting to the server.\n      var silentOptions = _.extend({}, options, {silent: true});\n      if (attrs && !this.set(attrs, options.wait ? silentOptions : options)) {\n        return false;\n      }\n\n      // After a successful server-side save, the client is (optionally)\n      // updated with the server-side state.\n      var model = this;\n      var success = options.success;\n      options.success = function(resp, status, xhr) {\n        var serverAttrs = model.parse(resp, xhr);\n        if (options.wait) {\n          delete options.wait;\n          serverAttrs = _.extend(attrs || {}, serverAttrs);\n        }\n        if (!model.set(serverAttrs, options)) return false;\n        if (success) {\n          success(model, resp);\n        } else {\n          model.trigger('sync', model, resp, options);\n        }\n      };\n\n      // Finish configuring and sending the Ajax request.\n      options.error = Backbone.wrapError(options.error, model, options);\n      var method = this.isNew() ? 'create' : 'update';\n      var xhr = (this.sync || Backbone.sync).call(this, method, this, options);\n      if (options.wait) this.set(current, silentOptions);\n      return xhr;\n    },\n\n    // Destroy this model on the server if it was already persisted.\n    // Optimistically removes the model from its collection, if it has one.\n    // If `wait: true` is passed, waits for the server to respond before removal.\n    destroy: function(options) {\n      options = options ? _.clone(options) : {};\n      var model = this;\n      var success = options.success;\n\n      var triggerDestroy = function() {\n        model.trigger('destroy', model, model.collection, options);\n      };\n\n      if (this.isNew()) {\n        triggerDestroy();\n        return false;\n      }\n\n      options.success = function(resp) {\n        if (options.wait) triggerDestroy();\n        if (success) {\n          success(model, resp);\n        } else {\n          model.trigger('sync', model, resp, options);\n        }\n      };\n\n      options.error = Backbone.wrapError(options.error, model, options);\n      var xhr = (this.sync || Backbone.sync).call(this, 'delete', this, options);\n      if (!options.wait) triggerDestroy();\n      return xhr;\n    },\n\n    // Default URL for the model's representation on the server -- if you're\n    // using Backbone's restful methods, override this to change the endpoint\n    // that will be called.\n    url: function() {\n      var base = getValue(this, 'urlRoot') || getValue(this.collection, 'url') || urlError();\n      if (this.isNew()) return base;\n      return base + (base.charAt(base.length - 1) == '/' ? '' : '/') + encodeURIComponent(this.id);\n    },\n\n    // **parse** converts a response into the hash of attributes to be `set` on\n    // the model. The default implementation is just to pass the response along.\n    parse: function(resp, xhr) {\n      return resp;\n    },\n\n    // Create a new model with identical attributes to this one.\n    clone: function() {\n      return new this.constructor(this.attributes);\n    },\n\n    // A model is new if it has never been saved to the server, and lacks an id.\n    isNew: function() {\n      return this.id == null;\n    },\n\n    // Call this method to manually fire a `\"change\"` event for this model and\n    // a `\"change:attribute\"` event for each changed attribute.\n    // Calling this will cause all objects observing the model to update.\n    change: function(options) {\n      options || (options = {});\n      var changing = this._changing;\n      this._changing = true;\n\n      // Silent changes become pending changes.\n      for (var attr in this._silent) this._pending[attr] = true;\n\n      // Silent changes are triggered.\n      var changes = _.extend({}, options.changes, this._silent);\n      this._silent = {};\n      for (var attr in changes) {\n        this.trigger('change:' + attr, this, this.get(attr), options);\n      }\n      if (changing) return this;\n\n      // Continue firing `\"change\"` events while there are pending changes.\n      while (!_.isEmpty(this._pending)) {\n        this._pending = {};\n        this.trigger('change', this, options);\n        // Pending and silent changes still remain.\n        for (var attr in this.changed) {\n          if (this._pending[attr] || this._silent[attr]) continue;\n          delete this.changed[attr];\n        }\n        this._previousAttributes = _.clone(this.attributes);\n      }\n\n      this._changing = false;\n      return this;\n    },\n\n    // Determine if the model has changed since the last `\"change\"` event.\n    // If you specify an attribute name, determine if that attribute has changed.\n    hasChanged: function(attr) {\n      if (!arguments.length) return !_.isEmpty(this.changed);\n      return _.has(this.changed, attr);\n    },\n\n    // Return an object containing all the attributes that have changed, or\n    // false if there are no changed attributes. Useful for determining what\n    // parts of a view need to be updated and/or what attributes need to be\n    // persisted to the server. Unset attributes will be set to undefined.\n    // You can also pass an attributes object to diff against the model,\n    // determining if there *would be* a change.\n    changedAttributes: function(diff) {\n      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;\n      var val, changed = false, old = this._previousAttributes;\n      for (var attr in diff) {\n        if (_.isEqual(old[attr], (val = diff[attr]))) continue;\n        (changed || (changed = {}))[attr] = val;\n      }\n      return changed;\n    },\n\n    // Get the previous value of an attribute, recorded at the time the last\n    // `\"change\"` event was fired.\n    previous: function(attr) {\n      if (!arguments.length || !this._previousAttributes) return null;\n      return this._previousAttributes[attr];\n    },\n\n    // Get all of the attributes of the model at the time of the previous\n    // `\"change\"` event.\n    previousAttributes: function() {\n      return _.clone(this._previousAttributes);\n    },\n\n    // Check if the model is currently in a valid state. It's only possible to\n    // get into an *invalid* state if you're using silent changes.\n    isValid: function() {\n      return !this.validate(this.attributes);\n    },\n\n    // Run validation against the next complete set of model attributes,\n    // returning `true` if all is well. If a specific `error` callback has\n    // been passed, call that instead of firing the general `\"error\"` event.\n    _validate: function(attrs, options) {\n      if (options.silent || !this.validate) return true;\n      attrs = _.extend({}, this.attributes, attrs);\n      var error = this.validate(attrs, options);\n      if (!error) return true;\n      if (options && options.error) {\n        options.error(this, error, options);\n      } else {\n        this.trigger('error', this, error, options);\n      }\n      return false;\n    }\n\n  });\n\n  // Backbone.Collection\n  // -------------------\n\n  // Provides a standard collection class for our sets of models, ordered\n  // or unordered. If a `comparator` is specified, the Collection will maintain\n  // its models in sort order, as they're added and removed.\n  var Collection = Backbone.Collection = function(models, options) {\n    options || (options = {});\n    if (options.model) this.model = options.model;\n    if (options.comparator) this.comparator = options.comparator;\n    this._reset();\n    this.initialize.apply(this, arguments);\n    if (models) this.reset(models, {silent: true, parse: options.parse});\n  };\n\n  // Define the Collection's inheritable methods.\n  _.extend(Collection.prototype, Events, {\n\n    // The default model for a collection is just a **Backbone.Model**.\n    // This should be overridden in most cases.\n    model: Model,\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){},\n\n    // The JSON representation of a Collection is an array of the\n    // models' attributes.\n    toJSON: function(options) {\n      return this.map(function(model){ return model.toJSON(options); });\n    },\n\n    // Add a model, or list of models to the set. Pass **silent** to avoid\n    // firing the `add` event for every new model.\n    add: function(models, options) {\n      var i, index, length, model, cid, id, cids = {}, ids = {}, dups = [];\n      options || (options = {});\n      models = _.isArray(models) ? models.slice() : [models];\n\n      // Begin by turning bare objects into model references, and preventing\n      // invalid models or duplicate models from being added.\n      for (i = 0, length = models.length; i < length; i++) {\n        if (!(model = models[i] = this._prepareModel(models[i], options))) {\n          throw new Error(\"Can't add an invalid model to a collection\");\n        }\n        cid = model.cid;\n        id = model.id;\n        if (cids[cid] || this._byCid[cid] || ((id != null) && (ids[id] || this._byId[id]))) {\n          dups.push(i);\n          continue;\n        }\n        cids[cid] = ids[id] = model;\n      }\n\n      // Remove duplicates.\n      i = dups.length;\n      while (i--) {\n        models.splice(dups[i], 1);\n      }\n\n      // Listen to added models' events, and index models for lookup by\n      // `id` and by `cid`.\n      for (i = 0, length = models.length; i < length; i++) {\n        (model = models[i]).on('all', this._onModelEvent, this);\n        this._byCid[model.cid] = model;\n        if (model.id != null) this._byId[model.id] = model;\n      }\n\n      // Insert models into the collection, re-sorting if needed, and triggering\n      // `add` events unless silenced.\n      this.length += length;\n      index = options.at != null ? options.at : this.models.length;\n      splice.apply(this.models, [index, 0].concat(models));\n      if (this.comparator) this.sort({silent: true});\n      if (options.silent) return this;\n      for (i = 0, length = this.models.length; i < length; i++) {\n        if (!cids[(model = this.models[i]).cid]) continue;\n        options.index = i;\n        model.trigger('add', model, this, options);\n      }\n      return this;\n    },\n\n    // Remove a model, or a list of models from the set. Pass silent to avoid\n    // firing the `remove` event for every model removed.\n    remove: function(models, options) {\n      var i, l, index, model;\n      options || (options = {});\n      models = _.isArray(models) ? models.slice() : [models];\n      for (i = 0, l = models.length; i < l; i++) {\n        model = this.getByCid(models[i]) || this.get(models[i]);\n        if (!model) continue;\n        delete this._byId[model.id];\n        delete this._byCid[model.cid];\n        index = this.indexOf(model);\n        this.models.splice(index, 1);\n        this.length--;\n        if (!options.silent) {\n          options.index = index;\n          model.trigger('remove', model, this, options);\n        }\n        this._removeReference(model);\n      }\n      return this;\n    },\n\n    // Add a model to the end of the collection.\n    push: function(model, options) {\n      model = this._prepareModel(model, options);\n      this.add(model, options);\n      return model;\n    },\n\n    // Remove a model from the end of the collection.\n    pop: function(options) {\n      var model = this.at(this.length - 1);\n      this.remove(model, options);\n      return model;\n    },\n\n    // Add a model to the beginning of the collection.\n    unshift: function(model, options) {\n      model = this._prepareModel(model, options);\n      this.add(model, _.extend({at: 0}, options));\n      return model;\n    },\n\n    // Remove a model from the beginning of the collection.\n    shift: function(options) {\n      var model = this.at(0);\n      this.remove(model, options);\n      return model;\n    },\n\n    // Get a model from the set by id.\n    get: function(id) {\n      if (id == null) return void 0;\n      return this._byId[id.id != null ? id.id : id];\n    },\n\n    // Get a model from the set by client id.\n    getByCid: function(cid) {\n      return cid && this._byCid[cid.cid || cid];\n    },\n\n    // Get the model at the given index.\n    at: function(index) {\n      return this.models[index];\n    },\n\n    // Return models with matching attributes. Useful for simple cases of `filter`.\n    where: function(attrs) {\n      if (_.isEmpty(attrs)) return [];\n      return this.filter(function(model) {\n        for (var key in attrs) {\n          if (attrs[key] !== model.get(key)) return false;\n        }\n        return true;\n      });\n    },\n\n    // Force the collection to re-sort itself. You don't need to call this under\n    // normal circumstances, as the set will maintain sort order as each item\n    // is added.\n    sort: function(options) {\n      options || (options = {});\n      if (!this.comparator) throw new Error('Cannot sort a set without a comparator');\n      var boundComparator = _.bind(this.comparator, this);\n      if (this.comparator.length == 1) {\n        this.models = this.sortBy(boundComparator);\n      } else {\n        this.models.sort(boundComparator);\n      }\n      if (!options.silent) this.trigger('reset', this, options);\n      return this;\n    },\n\n    // Pluck an attribute from each model in the collection.\n    pluck: function(attr) {\n      return _.map(this.models, function(model){ return model.get(attr); });\n    },\n\n    // When you have more items than you want to add or remove individually,\n    // you can reset the entire set with a new list of models, without firing\n    // any `add` or `remove` events. Fires `reset` when finished.\n    reset: function(models, options) {\n      models  || (models = []);\n      options || (options = {});\n      for (var i = 0, l = this.models.length; i < l; i++) {\n        this._removeReference(this.models[i]);\n      }\n      this._reset();\n      this.add(models, _.extend({silent: true}, options));\n      if (!options.silent) this.trigger('reset', this, options);\n      return this;\n    },\n\n    // Fetch the default set of models for this collection, resetting the\n    // collection when they arrive. If `add: true` is passed, appends the\n    // models to the collection instead of resetting.\n    fetch: function(options) {\n      options = options ? _.clone(options) : {};\n      if (options.parse === undefined) options.parse = true;\n      var collection = this;\n      var success = options.success;\n      options.success = function(resp, status, xhr) {\n        collection[options.add ? 'add' : 'reset'](collection.parse(resp, xhr), options);\n        if (success) success(collection, resp);\n      };\n      options.error = Backbone.wrapError(options.error, collection, options);\n      return (this.sync || Backbone.sync).call(this, 'read', this, options);\n    },\n\n    // Create a new instance of a model in this collection. Add the model to the\n    // collection immediately, unless `wait: true` is passed, in which case we\n    // wait for the server to agree.\n    create: function(model, options) {\n      var coll = this;\n      options = options ? _.clone(options) : {};\n      model = this._prepareModel(model, options);\n      if (!model) return false;\n      if (!options.wait) coll.add(model, options);\n      var success = options.success;\n      options.success = function(nextModel, resp, xhr) {\n        if (options.wait) coll.add(nextModel, options);\n        if (success) {\n          success(nextModel, resp);\n        } else {\n          nextModel.trigger('sync', model, resp, options);\n        }\n      };\n      model.save(null, options);\n      return model;\n    },\n\n    // **parse** converts a response into a list of models to be added to the\n    // collection. The default implementation is just to pass it through.\n    parse: function(resp, xhr) {\n      return resp;\n    },\n\n    // Proxy to _'s chain. Can't be proxied the same way the rest of the\n    // underscore methods are proxied because it relies on the underscore\n    // constructor.\n    chain: function () {\n      return _(this.models).chain();\n    },\n\n    // Reset all internal state. Called when the collection is reset.\n    _reset: function(options) {\n      this.length = 0;\n      this.models = [];\n      this._byId  = {};\n      this._byCid = {};\n    },\n\n    // Prepare a model or hash of attributes to be added to this collection.\n    _prepareModel: function(model, options) {\n      options || (options = {});\n      if (!(model instanceof Model)) {\n        var attrs = model;\n        options.collection = this;\n        model = new this.model(attrs, options);\n        if (!model._validate(model.attributes, options)) model = false;\n      } else if (!model.collection) {\n        model.collection = this;\n      }\n      return model;\n    },\n\n    // Internal method to remove a model's ties to a collection.\n    _removeReference: function(model) {\n      if (this == model.collection) {\n        delete model.collection;\n      }\n      model.off('all', this._onModelEvent, this);\n    },\n\n    // Internal method called every time a model in the set fires an event.\n    // Sets need to update their indexes when models change ids. All other\n    // events simply proxy through. \"add\" and \"remove\" events that originate\n    // in other collections are ignored.\n    _onModelEvent: function(event, model, collection, options) {\n      if ((event == 'add' || event == 'remove') && collection != this) return;\n      if (event == 'destroy') {\n        this.remove(model, options);\n      }\n      if (model && event === 'change:' + model.idAttribute) {\n        delete this._byId[model.previous(model.idAttribute)];\n        this._byId[model.id] = model;\n      }\n      this.trigger.apply(this, arguments);\n    }\n\n  });\n\n  // Underscore methods that we want to implement on the Collection.\n  var methods = ['forEach', 'each', 'map', 'reduce', 'reduceRight', 'find',\n    'detect', 'filter', 'select', 'reject', 'every', 'all', 'some', 'any',\n    'include', 'contains', 'invoke', 'max', 'min', 'sortBy', 'sortedIndex',\n    'toArray', 'size', 'first', 'initial', 'rest', 'last', 'without', 'indexOf',\n    'shuffle', 'lastIndexOf', 'isEmpty', 'groupBy'];\n\n  // Mix in each Underscore method as a proxy to `Collection#models`.\n  _.each(methods, function(method) {\n    Collection.prototype[method] = function() {\n      return _[method].apply(_, [this.models].concat(_.toArray(arguments)));\n    };\n  });\n\n  // Backbone.Router\n  // -------------------\n\n  // Routers map faux-URLs to actions, and fire events when routes are\n  // matched. Creating a new one sets its `routes` hash, if not set statically.\n  var Router = Backbone.Router = function(options) {\n    options || (options = {});\n    if (options.routes) this.routes = options.routes;\n    this._bindRoutes();\n    this.initialize.apply(this, arguments);\n  };\n\n  // Cached regular expressions for matching named param parts and splatted\n  // parts of route strings.\n  var namedParam    = /:\\w+/g;\n  var splatParam    = /\\*\\w+/g;\n  var escapeRegExp  = /[-[\\]{}()+?.,\\\\^$|#\\s]/g;\n\n  // Set up all inheritable **Backbone.Router** properties and methods.\n  _.extend(Router.prototype, Events, {\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){},\n\n    // Manually bind a single named route to a callback. For example:\n    //\n    //     this.route('search/:query/p:num', 'search', function(query, num) {\n    //       ...\n    //     });\n    //\n    route: function(route, name, callback) {\n      Backbone.history || (Backbone.history = new History);\n      if (!_.isRegExp(route)) route = this._routeToRegExp(route);\n      if (!callback) callback = this[name];\n      Backbone.history.route(route, _.bind(function(fragment) {\n        var args = this._extractParameters(route, fragment);\n        callback && callback.apply(this, args);\n        this.trigger.apply(this, ['route:' + name].concat(args));\n        Backbone.history.trigger('route', this, name, args);\n      }, this));\n      return this;\n    },\n\n    // Simple proxy to `Backbone.history` to save a fragment into the history.\n    navigate: function(fragment, options) {\n      Backbone.history.navigate(fragment, options);\n    },\n\n    // Bind all defined routes to `Backbone.history`. We have to reverse the\n    // order of the routes here to support behavior where the most general\n    // routes can be defined at the bottom of the route map.\n    _bindRoutes: function() {\n      if (!this.routes) return;\n      var routes = [];\n      for (var route in this.routes) {\n        routes.unshift([route, this.routes[route]]);\n      }\n      for (var i = 0, l = routes.length; i < l; i++) {\n        this.route(routes[i][0], routes[i][1], this[routes[i][1]]);\n      }\n    },\n\n    // Convert a route string into a regular expression, suitable for matching\n    // against the current location hash.\n    _routeToRegExp: function(route) {\n      route = route.replace(escapeRegExp, '\\\\$&')\n                   .replace(namedParam, '([^\\/]+)')\n                   .replace(splatParam, '(.*?)');\n      return new RegExp('^' + route + '$');\n    },\n\n    // Given a route, and a URL fragment that it matches, return the array of\n    // extracted parameters.\n    _extractParameters: function(route, fragment) {\n      return route.exec(fragment).slice(1);\n    }\n\n  });\n\n  // Backbone.History\n  // ----------------\n\n  // Handles cross-browser history management, based on URL fragments. If the\n  // browser does not support `onhashchange`, falls back to polling.\n  var History = Backbone.History = function() {\n    this.handlers = [];\n    _.bindAll(this, 'checkUrl');\n  };\n\n  // Cached regex for cleaning leading hashes and slashes .\n  var routeStripper = /^[#\\/]/;\n\n  // Cached regex for detecting MSIE.\n  var isExplorer = /msie [\\w.]+/;\n\n  // Has the history handling already been started?\n  History.started = false;\n\n  // Set up all inheritable **Backbone.History** properties and methods.\n  _.extend(History.prototype, Events, {\n\n    // The default interval to poll for hash changes, if necessary, is\n    // twenty times a second.\n    interval: 50,\n\n    // Gets the true hash value. Cannot use location.hash directly due to bug\n    // in Firefox where location.hash will always be decoded.\n    getHash: function(windowOverride) {\n      var loc = windowOverride ? windowOverride.location : window.location;\n      var match = loc.href.match(/#(.*)$/);\n      return match ? match[1] : '';\n    },\n\n    // Get the cross-browser normalized URL fragment, either from the URL,\n    // the hash, or the override.\n    getFragment: function(fragment, forcePushState) {\n      if (fragment == null) {\n        if (this._hasPushState || forcePushState) {\n          fragment = window.location.pathname;\n          var search = window.location.search;\n          if (search) fragment += search;\n        } else {\n          fragment = this.getHash();\n        }\n      }\n      if (!fragment.indexOf(this.options.root)) fragment = fragment.substr(this.options.root.length);\n      return fragment.replace(routeStripper, '');\n    },\n\n    // Start the hash change handling, returning `true` if the current URL matches\n    // an existing route, and `false` otherwise.\n    start: function(options) {\n      if (History.started) throw new Error(\"Backbone.history has already been started\");\n      // <METEOR>\n      if (typeof window === 'undefined')\n        throw new Error(\"Backbone.History is client-only, can't start on the server\");\n      // </METEOR>\n      History.started = true;\n\n      // Figure out the initial configuration. Do we need an iframe?\n      // Is pushState desired ... is it available?\n      this.options          = _.extend({}, {root: '/'}, this.options, options);\n      this._wantsHashChange = this.options.hashChange !== false;\n      this._wantsPushState  = !!this.options.pushState;\n      this._hasPushState    = !!(this.options.pushState && window.history && window.history.pushState);\n      var fragment          = this.getFragment();\n      var docMode           = document.documentMode;\n      var oldIE             = (isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7));\n\n      if (oldIE) {\n        this.iframe = $('<iframe src=\"javascript:0\" tabindex=\"-1\" />').hide().appendTo('body')[0].contentWindow;\n        this.navigate(fragment);\n      }\n\n      // Depending on whether we're using pushState or hashes, and whether\n      // 'onhashchange' is supported, determine how we check the URL state.\n      if (this._hasPushState) {\n        $(window).bind('popstate', this.checkUrl);\n      } else if (this._wantsHashChange && ('onhashchange' in window) && !oldIE) {\n        $(window).bind('hashchange', this.checkUrl);\n      } else if (this._wantsHashChange) {\n        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);\n      }\n\n      // Determine if we need to change the base url, for a pushState link\n      // opened by a non-pushState browser.\n      this.fragment = fragment;\n      var loc = window.location;\n      var atRoot  = loc.pathname == this.options.root;\n\n      // If we've started off with a route from a `pushState`-enabled browser,\n      // but we're currently in a browser that doesn't support it...\n      if (this._wantsHashChange && this._wantsPushState && !this._hasPushState && !atRoot) {\n        this.fragment = this.getFragment(null, true);\n        window.location.replace(this.options.root + '#' + this.fragment);\n        // Return immediately as browser will do redirect to new url\n        return true;\n\n      // Or if we've started out with a hash-based route, but we're currently\n      // in a browser where it could be `pushState`-based instead...\n      } else if (this._wantsPushState && this._hasPushState && atRoot && loc.hash) {\n        this.fragment = this.getHash().replace(routeStripper, '');\n        window.history.replaceState({}, document.title, loc.protocol + '//' + loc.host + this.options.root + this.fragment);\n      }\n\n      if (!this.options.silent) {\n        return this.loadUrl();\n      }\n    },\n\n    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,\n    // but possibly useful for unit testing Routers.\n    stop: function() {\n      $(window).unbind('popstate', this.checkUrl).unbind('hashchange', this.checkUrl);\n      clearInterval(this._checkUrlInterval);\n      History.started = false;\n    },\n\n    // Add a route to be tested when the fragment changes. Routes added later\n    // may override previous routes.\n    route: function(route, callback) {\n      this.handlers.unshift({route: route, callback: callback});\n    },\n\n    // Checks the current URL to see if it has changed, and if it has,\n    // calls `loadUrl`, normalizing across the hidden iframe.\n    checkUrl: function(e) {\n      var current = this.getFragment();\n      if (current == this.fragment && this.iframe) current = this.getFragment(this.getHash(this.iframe));\n      if (current == this.fragment) return false;\n      if (this.iframe) this.navigate(current);\n      this.loadUrl() || this.loadUrl(this.getHash());\n    },\n\n    // Attempt to load the current URL fragment. If a route succeeds with a\n    // match, returns `true`. If no defined routes matches the fragment,\n    // returns `false`.\n    loadUrl: function(fragmentOverride) {\n      var fragment = this.fragment = this.getFragment(fragmentOverride);\n      var matched = _.any(this.handlers, function(handler) {\n        if (handler.route.test(fragment)) {\n          handler.callback(fragment);\n          return true;\n        }\n      });\n      return matched;\n    },\n\n    // Save a fragment into the hash history, or replace the URL state if the\n    // 'replace' option is passed. You are responsible for properly URL-encoding\n    // the fragment in advance.\n    //\n    // The options object can contain `trigger: true` if you wish to have the\n    // route callback be fired (not usually desirable), or `replace: true`, if\n    // you wish to modify the current URL without adding an entry to the history.\n    navigate: function(fragment, options) {\n      if (!History.started) return false;\n      if (!options || options === true) options = {trigger: options};\n      var frag = (fragment || '').replace(routeStripper, '');\n      if (this.fragment == frag) return;\n\n      // If pushState is available, we use it to set the fragment as a real URL.\n      if (this._hasPushState) {\n        if (frag.indexOf(this.options.root) != 0) frag = this.options.root + frag;\n        this.fragment = frag;\n        window.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, frag);\n\n      // If hash changes haven't been explicitly disabled, update the hash\n      // fragment to store history.\n      } else if (this._wantsHashChange) {\n        this.fragment = frag;\n        this._updateHash(window.location, frag, options.replace);\n        if (this.iframe && (frag != this.getFragment(this.getHash(this.iframe)))) {\n          // Opening and closing the iframe tricks IE7 and earlier to push a history entry on hash-tag change.\n          // When replace is true, we don't want this.\n          if(!options.replace) this.iframe.document.open().close();\n          this._updateHash(this.iframe.location, frag, options.replace);\n        }\n\n      // If you've told us that you explicitly don't want fallback hashchange-\n      // based history, then `navigate` becomes a page refresh.\n      } else {\n        window.location.assign(this.options.root + fragment);\n      }\n      if (options.trigger) this.loadUrl(fragment);\n    },\n\n    // Update the hash location, either replacing the current entry, or adding\n    // a new one to the browser history.\n    _updateHash: function(location, fragment, replace) {\n      if (replace) {\n        location.replace(location.toString().replace(/(javascript:|#).*$/, '') + '#' + fragment);\n      } else {\n        location.hash = fragment;\n      }\n    }\n  });\n\n  // Backbone.View\n  // -------------\n\n  // Creating a Backbone.View creates its initial element outside of the DOM,\n  // if an existing element is not provided...\n  var View = Backbone.View = function(options) {\n    this.cid = _.uniqueId('view');\n    this._configure(options || {});\n    this._ensureElement();\n    this.initialize.apply(this, arguments);\n    this.delegateEvents();\n  };\n\n  // Cached regex to split keys for `delegate`.\n  var delegateEventSplitter = /^(\\S+)\\s*(.*)$/;\n\n  // List of view options to be merged as properties.\n  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName'];\n\n  // Set up all inheritable **Backbone.View** properties and methods.\n  _.extend(View.prototype, Events, {\n\n    // The default `tagName` of a View's element is `\"div\"`.\n    tagName: 'div',\n\n    // jQuery delegate for element lookup, scoped to DOM elements within the\n    // current view. This should be prefered to global lookups where possible.\n    $: function(selector) {\n      return this.$el.find(selector);\n    },\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){},\n\n    // **render** is the core function that your view should override, in order\n    // to populate its element (`this.el`), with the appropriate HTML. The\n    // convention is for **render** to always return `this`.\n    render: function() {\n      return this;\n    },\n\n    // Remove this view from the DOM. Note that the view isn't present in the\n    // DOM by default, so calling this method may be a no-op.\n    remove: function() {\n      this.$el.remove();\n      return this;\n    },\n\n    // For small amounts of DOM Elements, where a full-blown template isn't\n    // needed, use **make** to manufacture elements, one at a time.\n    //\n    //     var el = this.make('li', {'class': 'row'}, this.model.escape('title'));\n    //\n    make: function(tagName, attributes, content) {\n      var el = document.createElement(tagName);\n      if (attributes) $(el).attr(attributes);\n      if (content) $(el).html(content);\n      return el;\n    },\n\n    // Change the view's element (`this.el` property), including event\n    // re-delegation.\n    setElement: function(element, delegate) {\n      if (this.$el) this.undelegateEvents();\n      this.$el = (element instanceof $) ? element : $(element);\n      this.el = this.$el[0];\n      if (delegate !== false) this.delegateEvents();\n      return this;\n    },\n\n    // Set callbacks, where `this.events` is a hash of\n    //\n    // *{\"event selector\": \"callback\"}*\n    //\n    //     {\n    //       'mousedown .title':  'edit',\n    //       'click .button':     'save'\n    //       'click .open':       function(e) { ... }\n    //     }\n    //\n    // pairs. Callbacks will be bound to the view, with `this` set properly.\n    // Uses event delegation for efficiency.\n    // Omitting the selector binds the event to `this.el`.\n    // This only works for delegate-able events: not `focus`, `blur`, and\n    // not `change`, `submit`, and `reset` in Internet Explorer.\n    delegateEvents: function(events) {\n      if (!(events || (events = getValue(this, 'events')))) return;\n      this.undelegateEvents();\n      for (var key in events) {\n        var method = events[key];\n        if (!_.isFunction(method)) method = this[events[key]];\n        if (!method) throw new Error('Method \"' + events[key] + '\" does not exist');\n        var match = key.match(delegateEventSplitter);\n        var eventName = match[1], selector = match[2];\n        method = _.bind(method, this);\n        eventName += '.delegateEvents' + this.cid;\n        if (selector === '') {\n          this.$el.bind(eventName, method);\n        } else {\n          this.$el.delegate(selector, eventName, method);\n        }\n      }\n    },\n\n    // Clears all callbacks previously bound to the view with `delegateEvents`.\n    // You usually don't need to use this, but may wish to if you have multiple\n    // Backbone views attached to the same DOM element.\n    undelegateEvents: function() {\n      this.$el.unbind('.delegateEvents' + this.cid);\n    },\n\n    // Performs the initial configuration of a View with a set of options.\n    // Keys with special meaning *(model, collection, id, className)*, are\n    // attached directly to the view.\n    _configure: function(options) {\n      if (this.options) options = _.extend({}, this.options, options);\n      for (var i = 0, l = viewOptions.length; i < l; i++) {\n        var attr = viewOptions[i];\n        if (options[attr]) this[attr] = options[attr];\n      }\n      this.options = options;\n    },\n\n    // Ensure that the View has a DOM element to render into.\n    // If `this.el` is a string, pass it through `$()`, take the first\n    // matching element, and re-assign it to `el`. Otherwise, create\n    // an element from the `id`, `className` and `tagName` properties.\n    _ensureElement: function() {\n      if (!this.el) {\n        var attrs = getValue(this, 'attributes') || {};\n        if (this.id) attrs.id = this.id;\n        if (this.className) attrs['class'] = this.className;\n        this.setElement(this.make(this.tagName, attrs), false);\n      } else {\n        this.setElement(this.el, false);\n      }\n    }\n\n  });\n\n  // The self-propagating extend function that Backbone classes use.\n  var extend = function (protoProps, classProps) {\n    var child = inherits(this, protoProps, classProps);\n    child.extend = this.extend;\n    return child;\n  };\n\n  // Set up inheritance for the model, collection, and view.\n  Model.extend = Collection.extend = Router.extend = View.extend = extend;\n\n  // Backbone.sync\n  // -------------\n\n  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.\n  var methodMap = {\n    'create': 'POST',\n    'update': 'PUT',\n    'delete': 'DELETE',\n    'read':   'GET'\n  };\n\n  // Override this function to change the manner in which Backbone persists\n  // models to the server. You will be passed the type of request, and the\n  // model in question. By default, makes a RESTful Ajax request\n  // to the model's `url()`. Some possible customizations could be:\n  //\n  // * Use `setTimeout` to batch rapid-fire updates into a single request.\n  // * Send up the models as XML instead of JSON.\n  // * Persist models via WebSockets instead of Ajax.\n  //\n  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests\n  // as `POST`, with a `_method` parameter containing the true HTTP method,\n  // as well as all requests with the body as `application/x-www-form-urlencoded`\n  // instead of `application/json` with the model in a param named `model`.\n  // Useful when interfacing with server-side languages like **PHP** that make\n  // it difficult to read the body of `PUT` requests.\n  Backbone.sync = function(method, model, options) {\n    var type = methodMap[method];\n\n    // Default options, unless specified.\n    options || (options = {});\n\n    // Default JSON-request options.\n    var params = {type: type, dataType: 'json'};\n\n    // Ensure that we have a URL.\n    if (!options.url) {\n      params.url = getValue(model, 'url') || urlError();\n    }\n\n    // Ensure that we have the appropriate request data.\n    if (!options.data && model && (method == 'create' || method == 'update')) {\n      params.contentType = 'application/json';\n      params.data = JSON.stringify(model.toJSON());\n    }\n\n    // For older servers, emulate JSON by encoding the request into an HTML-form.\n    if (Backbone.emulateJSON) {\n      params.contentType = 'application/x-www-form-urlencoded';\n      params.data = params.data ? {model: params.data} : {};\n    }\n\n    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`\n    // And an `X-HTTP-Method-Override` header.\n    if (Backbone.emulateHTTP) {\n      if (type === 'PUT' || type === 'DELETE') {\n        if (Backbone.emulateJSON) params.data._method = type;\n        params.type = 'POST';\n        params.beforeSend = function(xhr) {\n          xhr.setRequestHeader('X-HTTP-Method-Override', type);\n        };\n      }\n    }\n\n    // Don't process data on a non-GET request.\n    if (params.type !== 'GET' && !Backbone.emulateJSON) {\n      params.processData = false;\n    }\n\n    // Make the request, allowing the user to override any Ajax options.\n    return $.ajax(_.extend(params, options));\n  };\n\n  // Wrap an optional error callback with a fallback error event.\n  Backbone.wrapError = function(onError, originalModel, options) {\n    return function(model, resp) {\n      resp = model === originalModel ? resp : model;\n      if (onError) {\n        onError(originalModel, resp, options);\n      } else {\n        originalModel.trigger('error', originalModel, resp, options);\n      }\n    };\n  };\n\n  // Helpers\n  // -------\n\n  // Shared empty constructor function to aid in prototype-chain creation.\n  var ctor = function(){};\n\n  // Helper function to correctly set up the prototype chain, for subclasses.\n  // Similar to `goog.inherits`, but uses a hash of prototype properties and\n  // class properties to be extended.\n  var inherits = function(parent, protoProps, staticProps) {\n    var child;\n\n    // The constructor function for the new subclass is either defined by you\n    // (the \"constructor\" property in your `extend` definition), or defaulted\n    // by us to simply call the parent's constructor.\n    if (protoProps && protoProps.hasOwnProperty('constructor')) {\n      child = protoProps.constructor;\n    } else {\n      child = function(){ parent.apply(this, arguments); };\n    }\n\n    // Inherit class (static) properties from parent.\n    _.extend(child, parent);\n\n    // Set the prototype chain to inherit from `parent`, without calling\n    // `parent`'s constructor function.\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n\n    // Add prototype properties (instance properties) to the subclass,\n    // if supplied.\n    if (protoProps) _.extend(child.prototype, protoProps);\n\n    // Add static properties to the constructor function, if supplied.\n    if (staticProps) _.extend(child, staticProps);\n\n    // Correctly set child's `prototype.constructor`.\n    child.prototype.constructor = child;\n\n    // Set a convenience property in case the parent's prototype is needed later.\n    child.__super__ = parent.prototype;\n\n    return child;\n  };\n\n  // Helper function to get a value from a Backbone object as a property\n  // or as a function.\n  var getValue = function(object, prop) {\n    if (!(object && object[prop])) return null;\n    return _.isFunction(object[prop]) ? object[prop]() : object[prop];\n  };\n\n  // Throw an error when a URL is needed, and none is supplied.\n  var urlError = function() {\n    throw new Error('A \"url\" property or function must be specified');\n  };\n\n}).call(this);\n"]}