{"version":3,"sources":["telescope-post-by-feed/lib/feeds.js","telescope-post-by-feed/lib/server/fetch_feeds.js","telescope-post-by-feed/lib/server/cron.js","telescope-post-by-feed/lib/server/publications.js","telescope-post-by-feed//Users/tutasg/meteor/telescope/packages/telescope-post-by-feed/i18n/en.i18n.json"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,mC;AACA,Q;AACA,iB;AACA,iC;AACA,I;AACA,W;AACA,iB;AACA,sB;AACA,e;AACA,2D;AACA,4B;AACA,6D;AACA,kB;AACA,4B;AACA,uC;AACA,a;AACA,W;AACA,qB;AACA,O;AACA,K;AACA,G;AACA,G;;AAEA,uC;AACA,+B;;AAEA,4D;AACA,sB;AACA,yB;AACA,mB;AACA,iB;AACA,oB;AACA,mB;AACA,e;AACA,gB;AACA,K;AACA,G;AACA,C;AACA,qC;;AAEA,8C;AACA,0B;AACA,6B;AACA,mB;AACA,iB;AACA,wB;AACA,mB;AACA,e;AACA,gB;AACA,K;AACA,G;AACA,C;AACA,yC;;AAEA,4B;AACA,e;AACA,wB;AACA,wB;AACA,uB;AACA,K;;AAEA,kB;AACA,kC;AACA,iC;;AAEA,+C;AACA,gF;;AAEA,oD;AACA,gH;;AAEA,mC;AACA,K;AACA,K;AACA,G;;;;;;;;;;;;;;;;;;;AC1EA,4C;AACA,uD;AACA,0B;;AAEA,oC;AACA,uE;AACA,C;;AAEA,wC;AACA,oB;;AAEA,iF;AACA,4C;;AAEA,2C;;AAEA,wB;;AAEA,kD;AACA,I;AACA,mC;AACA,iD;AACA,8C;AACA,Y;AACA,sB;;AAEA,kB;AACA,qC;AACA,uB;AACA,wB;AACA,4B;AACA,sB;AACA,O;;AAEA,2B;AACA,4D;;AAEA,0B;;AAEA,uE;AACA,8D;AACA,8H;AACA,wC;AACA,O;;AAEA,uC;AACA,uB;AACA,sD;;AAEA,W;AACA,yB;AACA,uB;AACA,mD;AACA,oB;AACA,O;;AAEA,K;AACA,K;;AAEA,uD;AACA,E;;AAEA,yB;AACA,c;;AAEA,uC;;AAEA,uD;AACA,uE;;AAEA,S;;AAEA,2C;AACA,+D;AACA,uF;AACA,4B;AACA,mB;;AAEA,qB;;AAEA,yB;AACA,yC;AACA,M;AACA,K;AACA,K;AACA,C;;AAEA,gB;AACA,2B;AACA,iB;AACA,I;AACA,iC;AACA,iC;AACA,I;AACA,mC;AACA,kC;AACA,I;AACA,E;;;;;;;;;;;;;;;;;;;ACjGA,sB;AACA,a;AACA,gC;AACA,c;AACA,uB;AACA,C;;AAEA,0B;AACA,kB;AACA,6B;AACA,gC;AACA,6C;AACA,O;AACA,qB;AACA,iC;AACA,qB;AACA,O;AACA,K;AACA,K;AACA,C;;AAEA,4B;AACA,W;AACA,E;;;;;;;;;;;;;;;;;;;ACvBA,oC;AACA,+B;AACA,wB;AACA,G;AACA,Y;AACA,G;;;;;;;;;;;;;;;;;;;ACLA,6B;AACA,6B;AACA,0B;;AAEA,gC;AACA,yD;AACA,C;AACA,+G;AACA,sD;AACA,gD;AACA,kB;AACA,wQ;AACA,gD","file":"/packages/telescope-post-by-feed.js","sourcesContent":["var feedSchema = new SimpleSchema({\n  url: {\n    type: String,\n    regEx: SimpleSchema.RegEx.Url\n  },\n  userId: {\n    type: String,\n    label: 'feedUser',\n    autoform: {\n      instructions: 'Posts will be assigned to this user.',\n      options: function () {\n        var users = Meteor.users.find().map(function (user) {\n          return {\n            value: user._id,\n            label: getDisplayName(user)\n          }  \n        });\n        return users;\n      }\n    }\n  }\n});\n\nFeeds = new Meteor.Collection(\"feeds\");\nFeeds.attachSchema(feedSchema);\n\n// used to keep track of which feed a post was imported from\nvar feedIdProperty = {\n  propertyName: 'feedId',\n  propertySchema: {\n    type: String,\n    label: 'feedId',\n    optional: true,\n    autoform: {\n      omit: true\n    }\n  }\n}\naddToPostSchema.push(feedIdProperty);\n\n// the RSS ID of the post in its original feed\nvar feedItemIdProperty = {\n  propertyName: 'feedItemId',\n  propertySchema: {\n    type: String,\n    label: 'feedItemId',\n    optional: true,\n    autoform: {\n      omit: true\n    }\n  }\n}\naddToPostSchema.push(feedItemIdProperty);\n\nMeteor.startup(function () {\n  Feeds.allow({\n    insert: isAdminById,\n    update: isAdminById,\n    remove: isAdminById\n  });\n\n  Meteor.methods({\n    insertFeed: function(feedUrl){\n      check(feedUrl, feedSchema);\n\n      if (Feeds.findOne({url: feedSchema.url}))\n        throw new Meteor.Error('already-exists', i18n.t('feed_already_exists'));\n\n      if (!Meteor.user() || !isAdmin(Meteor.user()))\n        throw new Meteor.Error('login-required', i18n.t('you_need_to_login_and_be_an_admin_to_add_a_new_feed'));\n\n      return Feeds.insert(feedUrl);\n    }\n  });\n});\n","var htmlParser = Npm.require('htmlparser2');\nvar toMarkdown = Npm.require('to-markdown').toMarkdown;\nvar he = Npm.require('he')\n\nvar getFirstAdminUser = function() {\n  return Meteor.users.findOne({isAdmin: true}, {sort: {createdAt: 1}});\n}\n\nvar handleFeed = function(error, feed) {\n  if (error) return;\n\n  var feedItems = _.first(feed.items, 20); // limit feed to 20 items just in case\n  var userId = this._parser._options.userId;\n\n  clog('// Parsing RSS feed: '+ feed.title)\n\n  var newItemsCount = 0;\n\n  feedItems.forEach(function(item, index, array) {\n    \n    // check if post already exists\n    if (!!Posts.findOne({feedItemId: item.id})) {\n      // clog('// Feed item already imported')\n    } else {\n      newItemsCount++;\n\n      var post = {\n        title: he.decode(item.title),\n        url: item.link,\n        feedId: feed.id,\n        feedItemId: item.id,\n        userId: userId\n      }\n\n      if (item.description)\n        post.body = toMarkdown(he.decode(item.description));\n\n      // console.log(feed)\n\n      // if RSS item link is a 301 or 302 redirect, follow the redirect\n      var get = HTTP.get(item.link, {followRedirects: false});\n      if (!!get.statusCode && (get.statusCode === 301 || get.statusCode === 302) && !!get.headers && !!get.headers.location) {\n        post.url = get.headers.location;\n      }\n\n      // if RSS item has a date, use it\n      if (item.pubDate)\n        post.postedAt = moment(item.pubDate).toDate();\n\n      try {\n        submitPost(post);\n      } catch (error) {\n        // catch errors so they don't stop the loop\n        clog(error);\n      }\n\n    }\n  });\n\n  clog('// Found ' + newItemsCount + ' new feed items')\n};\n\nfetchFeeds = function() {\n  var content;\n\n  Feeds.find().forEach(function(feed) {\n\n    // if feed doesn't specify a user, default to admin\n    var userId = !!feed.userId ? feed.userId : getFirstAdminUser()._id;\n\n    try {\n\n      content = HTTP.get(feed.url).content;\n      var feedHandler = new htmlParser.FeedHandler(handleFeed);\n      var parser = new htmlParser.Parser(feedHandler, {xmlMode: true, userId: userId});\n      parser.write(content);\n      parser.end();\n\n    } catch (error) {\n\n      console.log(error);\n      return true; // just go to next url\n      \n    }\n  });\n}\n\nMeteor.methods({\n  fetchFeeds: function () {\n    fetchFeeds();\n  },\n  testEntities: function (text) {\n    console.log(he.decode(text));\n  },\n  testToMarkdown: function (text) {\n    console.log(toMarkdown(text));\n  } \n})\n","SyncedCron.options = {\n  log: false,\n  collectionName: 'cronHistory',\n  utc: false, \n  collectionTTL: 172800\n}\n\nvar addJob = function () {\n  SyncedCron.add({\n    name: 'Post by RSS feed',\n    schedule: function(parser) {\n      return parser.text('every 30 minutes');\n    }, \n    job: function() {\n      if (Feeds.find().count()) {\n        fetchFeeds();\n      }\n    }\n  });\n}\n\nMeteor.startup(function () {\n  addJob();\n})\n","Meteor.publish('feeds', function() {\n  if(isAdminById(this.userId)){\n    return Feeds.find();\n  }\n  return [];\n});\n","var _ = Package.underscore._,\n    package_name = \"project\",\n    namespace = \"project\";\n\nif (package_name != \"project\") {\n    namespace = TAPi18n.packages[package_name].namespace;\n}\nTAPi18n._enable({\"helper_name\":\"_\",\"supported_languages\":null,\"i18n_files_route\":\"/tap-i18n\",\"cdn_path\":null});\nTAPi18n.languages_names[\"en\"] = [\"English\",\"English\"];\n// integrate the fallback language translations \ntranslations = {};\ntranslations[namespace] = {\"feed_already_exists\":\"A feed with the same URL already exists.\",\"you_need_to_login_and_be_an_admin_to_add_a_new_feed\":\"You need to log in and be an admin to add a new feed.\",\"import_new_posts_from_feeds\":\"Import new posts from feeds.\"};\nTAPi18n._loadLangFileObject(\"en\", translations);\n"]}